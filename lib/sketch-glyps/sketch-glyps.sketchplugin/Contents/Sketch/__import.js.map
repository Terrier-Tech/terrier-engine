{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/child_process/index.js","webpack://exports/./node_modules/@skpm/child_process/lib/exec.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFile.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFileSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/execSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/handleData.js","webpack://exports/./node_modules/@skpm/child_process/lib/normalizeSpawnArguments.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawn.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawnSync.js","webpack://exports/./node_modules/@skpm/fs/index.js","webpack://exports/./node_modules/@skpm/fs/utils.js","webpack://exports/./src/import.js","webpack://exports/external \"buffer\"","webpack://exports/external \"events\"","webpack://exports/external \"sketch\"","webpack://exports/external \"stream\""],"names":["fs","require","childProcess","numCols","artboardSize","padding","cellSpan","context","pumaDir","clypboardDir","execSync","toString","indexOf","trim","console","log","UI","alert","document","sketch","Document","getSelectedDocument","page","selectedPage","name","layers","child","remove","Page","parent","rootDir","files","readdirSync","col","row","names","file","endsWith","push","sort","x","y","artboard","Artboard","replace","frame","width","height","exportFormats","fileFormat","svg","readFileSync","group","createLayerFromData","layer","grid","MSDefaultGrid","defaultGrid","setGridSize","setThickGridTimes","setIsEnabled","sketchObject","setGrid","message","length"],"mappings":";;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,sBAAsB,mBAAO,CAAC,kEAAY;AAC1C,0BAA0B,mBAAO,CAAC,0EAAgB;AAClD,uBAAuB,mBAAO,CAAC,oEAAa;AAC5C,2BAA2B,mBAAO,CAAC,4EAAiB;AACpD,8BAA8B,mBAAO,CAAC,kFAAoB;AAC1D,0BAA0B,mBAAO,CAAC,0EAAgB;;;;;;;;;;;;ACLlD,eAAe,mBAAO,CAAC,sEAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA,YAAY,mBAAO,CAAC,gEAAS;AAC7B,iBAAiB,mBAAO,CAAC,0EAAc;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1KA,gBAAgB,mBAAO,CAAC,wEAAa;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC5DA,mBAAmB,mBAAO,CAAC,8EAAgB;;AAE3C;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChBA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,gBAAgB,mBAAO,CAAC,wEAAa;AACrC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;AC1OA;AACA,iBAAiB,mBAAO,CAAC,0EAAc;AACvC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnHA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,YAAY,mBAAO,CAAC,iDAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"__import.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/import.js\");\n","module.exports.exec = require('./lib/exec')\nmodule.exports.execFile = require('./lib/execFile')\nmodule.exports.spawn = require('./lib/spawn')\nmodule.exports.spawnSync = require('./lib/spawnSync')\nmodule.exports.execFileSync = require('./lib/execFileSync')\nmodule.exports.execSync = require('./lib/execSync')\n","var execFile = require('./execFile')\n\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = undefined\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n  options.shell = typeof options.shell === 'string' ? options.shell : true\n\n  return {\n    file: command,\n    options: options,\n    callback: callback\n  }\n}\n\nmodule.exports = function exec(command, options, callback) {\n  var opts = normalizeExecArgs(command, options, callback)\n  return execFile(opts.file, opts.options, opts.callback)\n}\n","/* globals NSMutableData, NSData */\nvar spawn = require('./spawn')\nvar handleData = require('./handleData')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout')\n  }\n}\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer')\n  }\n}\n\nfunction concatData(prev, data) {\n  prev.appendData(data)\n  return prev\n}\n\nmodule.exports = function execFile(file, args, options, callback) {\n  var defaultOptions = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: undefined,\n    env: undefined,\n    shell: false\n  }\n\n  if (typeof args === 'function') {\n    // function (file, callback)\n    callback = args\n    args = []\n    options = defaultOptions\n  } else if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options, callback)\n    callback = options\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file, args, options, callback)\n    options = Object.assign(defaultOptions, options)\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout)\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer)\n\n  var child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell\n  })\n\n  var encoding = options.encoding\n  var _stdout = []\n  var _stderr = []\n\n  var stdoutLen = 0\n  var stderrLen = 0\n  var killed = false\n  var exited = false\n  var timeoutId\n\n  var ex = null\n\n  var cmd = file\n\n  function exithandler(code, signal) {\n    if (exited) return\n    exited = true\n\n    if (timeoutId) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n\n    if (!callback) return\n\n    // merge chunks\n    var stdout = handleData(\n      NSData.dataWithData(_stdout.reduce(concatData, NSMutableData.data())),\n      encoding\n    )\n    var stderr = handleData(\n      NSData.dataWithData(_stderr.reduce(concatData, NSMutableData.data())),\n      encoding\n    )\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr)\n      return\n    }\n\n    if (args.length !== 0) {\n      cmd += ' ' + args.join(' ')\n    }\n\n    if (!ex) {\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr)\n      ex.killed = child.killed || killed\n      ex.code = code\n      ex.signal = signal\n    }\n\n    ex.cmd = cmd\n    callback(ex, stdout, stderr)\n  }\n\n  function errorhandler(e) {\n    ex = e\n\n    exithandler()\n  }\n\n  function kill() {\n    killed = true\n    try {\n      child.kill(options.killSignal)\n    } catch (e) {\n      ex = e\n      exithandler()\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill()\n      timeoutId = null\n    }, options.timeout)\n  }\n\n  if (child.stdout) {\n    child.stdout.setEncoding('NSData')\n    child.stdout.on('data', function onChildStdout(chunk) {\n      stdoutLen += chunk.length()\n      if (stdoutLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stdout')\n        kill()\n      } else {\n        _stdout.push(chunk)\n      }\n    })\n  }\n\n  if (child.stderr) {\n    child.stderr.setEncoding('NSData')\n    child.stderr.on('data', function onChildStderr(chunk) {\n      stderrLen += chunk.length()\n\n      if (stderrLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stderr')\n        kill()\n      } else {\n        _stderr.push(chunk)\n      }\n    })\n  }\n\n  child.addListener('close', exithandler)\n  child.addListener('error', errorhandler)\n\n  return child\n}\n","var spawnSync = require('./spawnSync')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout')\n  }\n}\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer')\n  }\n}\n\nmodule.exports = function execFileSync(file, args, options) {\n  var defaultOptions = {\n    encoding: 'buffer',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: null,\n    env: null,\n    shell: false\n  }\n\n  if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options)\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file)\n    options = Object.assign(defaultOptions, options || {})\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout)\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer)\n\n  var child = spawnSync(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n    encoding: options.encoding,\n    stdio: ['pipe', 'pipe', 'inherit']\n  })\n\n  if (child.status !== 0) {\n    var error = new Error('Failed to run: ' + String(child.stderr))\n    error.pid = child.pid\n    error.status = child.status\n    error.stdout = child.stdout\n    error.stderr = child.stderr\n    throw error\n  }\n\n  return child.stdout\n}\n","var execFileSync = require('./execFileSync')\n\nfunction normalizeExecArgs(command, options) {\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n  options.shell = typeof options.shell === 'string' ? options.shell : true\n\n  return {\n    file: command,\n    options: options\n  }\n}\n\nmodule.exports = function execSync(command, options) {\n  var opts = normalizeExecArgs(command, options)\n  return execFileSync(opts.file, opts.options)\n}\n","var Buffer = require('buffer').Buffer\n\nfunction handleBuffer(buffer, encoding) {\n  if (encoding === 'buffer') {\n    return buffer\n  }\n  if (encoding === 'NSData') {\n    return buffer.toNSData()\n  }\n  return buffer.toString(encoding)\n}\n\nmodule.exports = function handleData(data, encoding) {\n  var buffer = Buffer.from(data)\n\n  return handleBuffer(buffer, encoding)\n}\n","module.exports = function normalizeSpawnArguments(file, args, options) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error('ERR_INVALID_ARG_TYPE')\n  }\n\n  if (Array.isArray(args)) {\n    args = args.slice(0)\n  } else if (\n    args !== undefined &&\n    (args === null || typeof args !== 'object')\n  ) {\n    throw new Error('ERR_INVALID_ARG_TYPE args')\n  } else {\n    options = args\n    args = []\n  }\n\n  if (options === undefined) {\n    options = {}\n  } else if (options === null || typeof options !== 'object') {\n    throw new Error('ERR_INVALID_ARG_TYPE options')\n  }\n\n  // Validate the cwd, if present.\n  if (options.cwd != null && typeof options.cwd !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.cwd')\n  }\n\n  // Validate detached, if present.\n  if (options.detached != null && typeof options.detached !== 'boolean') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.detached')\n  }\n\n  // Validate the uid, if present.\n  if (options.uid != null && !Number.isInteger(options.uid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.uid')\n  }\n\n  // Validate the gid, if present.\n  if (options.gid != null && !Number.isInteger(options.gid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.gid')\n  }\n\n  // Validate the shell, if present.\n  if (\n    options.shell != null &&\n    typeof options.shell !== 'boolean' &&\n    typeof options.shell !== 'string'\n  ) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.shell')\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null && typeof options.argv0 !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.argv0')\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n\n  if (options.shell) {\n    var command = [file].concat(args).join(' ')\n\n    if (typeof options.shell === 'string') {\n      file = options.shell\n    } else {\n      file = '/bin/bash'\n    }\n    args = ['-l', '-c', command]\n  }\n\n  if (typeof options.argv0 === 'string') {\n    args.unshift(options.argv0)\n  }\n\n  var stdio = ['pipe', 'pipe', 'pipe']\n\n  if (typeof options.stdio === 'string') {\n    if (options.stdio === 'inherit') {\n      stdio = [0, 1, 2]\n    } else {\n      stdio = [options.stdio, options.stdio, options.stdio]\n    }\n  } else if (Array.isArray(options.stdio)) {\n    if (options.stdio[0] || options.stdio[0] === 0) {\n      if (options.stdio[0] === 'inherit') {\n        stdio[0] = 0\n      } else {\n        stdio[0] = options.stdio[0]\n      }\n    }\n    if (options.stdio[1] || options.stdio[1] === 0) {\n      if (options.stdio[1] === 'inherit') {\n        stdio[1] = 1\n      } else {\n        stdio[1] = options.stdio[1]\n      }\n    }\n    if (options.stdio[2] || options.stdio[2] === 0) {\n      if (options.stdio[2] === 'inherit') {\n        stdio[2] = 2\n      } else {\n        stdio[2] = options.stdio[2]\n      }\n    }\n  }\n\n  var env = options.env\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    envPairs: env,\n    stdio: stdio\n  }\n}\n","/* globals NSPipe, NSTask, NSArray, NSString, coscript, __mocha__ */\nvar Buffer = require('buffer').Buffer\nvar EventEmitter = require('events')\nvar Readable = require('stream').Readable\nvar Writable = require('stream').Writable\n\nvar spawnSync = require('./spawnSync')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nmodule.exports = function spawn(_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options)\n\n  var result = new EventEmitter()\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync(\n      '/bin/bash',\n      ['-l', '-c', 'which ' + opts.file],\n      { encoding: 'utf8' }\n    )\n    var resolvedCommand = String(whichChild.stdout || '').trim()\n    if (whichChild.err || !resolvedCommand.length) {\n      result.stderr = new EventEmitter()\n      result.stdout = new EventEmitter()\n\n      result.pid = '-1'\n\n      result.stderr.setEncoding = function setEncoding(encoding) {\n        result.stderr.encoding = encoding\n      }\n      result.stdout.setEncoding = function setEncoding(encoding) {\n        result.stdout.encoding = encoding\n      }\n      if (!resolvedCommand.length) {\n        result.emit('error', new Error(String(opts.file) + ' ENOENT'))\n      } else {\n        result.emit('error', whichChild.err)\n      }\n      return result\n    }\n    return spawn(resolvedCommand, _args, _options)\n  }\n\n  var options = opts.options\n\n  result.killed = false\n\n  var fiber = coscript.createFiber()\n\n  var task\n  var signal = null\n\n  var readingStderr = false\n  var readingStdout = false\n\n  result.stderr = new Readable({\n    read: function read() {\n      readingStderr = true\n    }\n  })\n  result.stdout = new Readable({\n    read: function read() {\n      readingStdout = true\n    }\n  })\n\n  function onStdout(data) {\n    if (data && data.length() && readingStdout) {\n      if (!result.stdout.push(Buffer.from(data))) {\n        readingStdout = false\n        task\n          .standardOutput()\n          .fileHandleForReading()\n          .setReadabilityHandler(null)\n      }\n    }\n  }\n  function onStderr(data) {\n    if (data && data.length() && readingStderr) {\n      if (!result.stderr.push(Buffer.from(data))) {\n        readingStderr = false\n        task\n          .standardError()\n          .fileHandleForReading()\n          .setReadabilityHandler(null)\n      }\n    }\n  }\n\n  result.sdtin = new Writable({\n    write: function write(chunk, encoding, callback) {\n      task\n        .standardInput()\n        .fileHandleForWriting()\n        .writeData(chunk.toNSData())\n      callback()\n    },\n    final: function finish(callback) {\n      task\n        .standardInput()\n        .fileHandleForWriting()\n        .closeFile()\n      callback()\n    }\n  })\n\n  result.sdtio = [result.sdtin, result.sdtout, result.sdterr]\n\n  try {\n    task = NSTask.alloc().init()\n\n    var inPipe = NSPipe.pipe()\n    var pipe = NSPipe.pipe()\n    var errPipe = NSPipe.pipe()\n\n    task.setStandardInput(inPipe)\n    task.setStandardOutput(pipe)\n    task.setStandardError(errPipe)\n\n    task\n      .standardOutput()\n      .fileHandleForReading()\n      .setReadabilityHandler(\n        __mocha__.createBlock_function(\n          'v16@?0@\"NSFileHandle\"8',\n          function readStdOut(fileHandle) {\n            try {\n              onStdout(fileHandle.availableData())\n            } catch (err) {\n              if (\n                typeof process !== 'undefined' &&\n                process.listenerCount &&\n                process.listenerCount('uncaughtException')\n              ) {\n                process.emit('uncaughtException', err, 'uncaughtException')\n              } else {\n                console.error(err)\n              }\n            }\n          }\n        )\n      )\n    task\n      .standardError()\n      .fileHandleForReading()\n      .setReadabilityHandler(\n        __mocha__.createBlock_function(\n          'v16@?0@\"NSFileHandle\"8',\n          function readStdOut(fileHandle) {\n            try {\n              onStderr(fileHandle.availableData())\n            } catch (err) {\n              if (\n                typeof process !== 'undefined' &&\n                process.listenerCount &&\n                process.listenerCount('uncaughtException')\n              ) {\n                process.emit('uncaughtException', err, 'uncaughtException')\n              } else {\n                console.error(err)\n              }\n            }\n          }\n        )\n      )\n\n    task.setLaunchPath(\n      NSString.stringWithString(opts.file).stringByExpandingTildeInPath()\n    )\n    task.arguments = NSArray.arrayWithArray(opts.args || [])\n    if (opts.envPairs) {\n      task.environment = opts.envPairs\n    }\n    if (options.cwd) {\n      task.setCurrentDirectoryPath(\n        NSString.stringWithString(options.cwd).stringByExpandingTildeInPath()\n      )\n    }\n\n    task.setTerminationHandler(\n      __mocha__.createBlock_function(\n        'v16@?0@\"NSTask\"8',\n        function handleTermination(_task) {\n          try {\n            _task\n              .standardError()\n              .fileHandleForReading()\n              .setReadabilityHandler(null)\n            _task\n              .standardOutput()\n              .fileHandleForReading()\n              .setReadabilityHandler(null)\n            result.stderr.emit('close')\n            result.stdout.emit('close')\n\n            result.killed = true\n\n            result.emit('close', Number(_task.terminationStatus()), signal)\n          } catch (err) {\n            if (\n              typeof process !== 'undefined' &&\n              process.listenerCount &&\n              process.listenerCount('uncaughtException')\n            ) {\n              process.emit('uncaughtException', err, 'uncaughtException')\n            } else {\n              console.error(err)\n            }\n          }\n          fiber.cleanup()\n        }\n      )\n    )\n\n    task.launch()\n  } catch (err) {\n    fiber.cleanup()\n    setImmediate(function() {\n      result.emit('error', err)\n    })\n    return result\n  }\n\n  result.kill = function kill(_signal) {\n    if (!result.killed) {\n      signal = _signal\n      task.terminate()\n    }\n  }\n\n  result.pid = String(task.processIdentifier())\n\n  return result\n}\n","/* globals NSPipe, NSTask, NSArray, NSString */\nvar handleData = require('./handleData')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nfunction spawnSync(_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options)\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync(\n      '/bin/bash',\n      ['-l', '-c', 'which ' + opts.file],\n      { encoding: 'utf8' }\n    )\n    if (whichChild.err) {\n      return whichChild\n    }\n    var resolvedCommand = String(whichChild.stdout).trim()\n    if (!resolvedCommand.length) {\n      return {\n        err: new Error(String(opts.file) + ' ENOENT')\n      }\n    }\n    return spawnSync(resolvedCommand, _args, _options)\n  }\n\n  var options = opts.options\n\n  var pipe = NSPipe.pipe()\n  var errPipe = NSPipe.pipe()\n\n  try {\n    var task = NSTask.alloc().init()\n    task.setLaunchPath(\n      NSString.stringWithString(opts.file).stringByExpandingTildeInPath()\n    )\n    task.arguments = NSArray.arrayWithArray(opts.args || [])\n    if (opts.envPairs) {\n      task.environment = opts.envPairs\n    }\n\n    if (options.cwd) {\n      task.setCurrentDirectoryPath(\n        NSString.stringWithString(options.cwd).stringByExpandingTildeInPath()\n      )\n    }\n\n    task.setStandardOutput(pipe)\n    task.setStandardError(errPipe)\n\n    task.launch()\n    task.waitUntilExit()\n\n    var stdoutIgnored = false\n    var stderrIgnored = false\n\n    var data\n    var stdoutValue\n    var stderrValue\n\n    if (opts.stdio[1] === 'ignored') {\n      stdoutIgnored = true\n    } else if (opts.stdio[1] === 1) {\n      data = pipe.fileHandleForReading().readDataToEndOfFile()\n      stdoutValue = handleData(data, options.encoding || 'buffer')\n      console.log(stdoutValue)\n    } else if (opts.stdio[1] === 2) {\n      data = pipe.fileHandleForReading().readDataToEndOfFile()\n      stdoutValue = handleData(data, options.encoding || 'buffer')\n      console.error(stdoutValue)\n    }\n\n    if (opts.stdio[2] === 'ignored') {\n      stderrIgnored = true\n    } else if (opts.stdio[2] === 1) {\n      data = errPipe.fileHandleForReading().readDataToEndOfFile()\n      stderrValue = handleData(data, options.encoding || 'buffer')\n      console.log(stderrValue)\n    } else if (opts.stdio[2] === 2) {\n      data = errPipe.fileHandleForReading().readDataToEndOfFile()\n      stderrValue = handleData(data, options.encoding || 'buffer')\n      console.error(stderrValue)\n    }\n\n    return {\n      pid: String(task.processIdentifier()),\n      status: Number(task.terminationStatus()),\n      get stdout() {\n        if (stdoutIgnored) {\n          return null\n        }\n        if (stdoutValue) {\n          return stdoutValue\n        }\n        data = pipe.fileHandleForReading().readDataToEndOfFile()\n        return handleData(data, options.encoding || 'buffer')\n      },\n      get stderr() {\n        if (stderrIgnored) {\n          return null\n        }\n        if (stderrValue) {\n          return stdoutValue\n        }\n        data = errPipe.fileHandleForReading().readDataToEndOfFile()\n        return handleData(data, options.encoding || 'buffer')\n      }\n    }\n  } catch (err) {\n    return {\n      err: err\n    }\n  }\n}\n\nmodule.exports = spawnSync\n","// TODO: async. Should probably be done with NSFileHandle and some notifications\n// TODO: file descriptor. Needs to be done with NSFileHandle\nvar Buffer = require(\"buffer\").Buffer;\nvar utils = require(\"./utils\");\nvar parseStat = utils.parseStat;\nvar fsError = utils.fsError;\nvar fsErrorForPath = utils.fsErrorForPath;\nvar encodingFromOptions = utils.encodingFromOptions;\nvar NOT_IMPLEMENTED = utils.NOT_IMPLEMENTED;\n\nmodule.exports.constants = {\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n};\n\nmodule.exports.access = NOT_IMPLEMENTED(\"access\");\n\nmodule.exports.accessSync = function (path, mode) {\n  mode = mode | 0;\n  var fileManager = NSFileManager.defaultManager();\n\n  switch (mode) {\n    case 0:\n      canAccess = module.exports.existsSync(path);\n      break;\n    case 1:\n      canAccess = Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n    case 2:\n      canAccess = Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 3:\n      canAccess =\n        Boolean(Number(fileManager.isExecutableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 4:\n      canAccess = Boolean(Number(fileManager.isReadableFileAtPath(path)));\n      break;\n    case 5:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n    case 6:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path)));\n      break;\n    case 7:\n      canAccess =\n        Boolean(Number(fileManager.isReadableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isWritableFileAtPath(path))) &&\n        Boolean(Number(fileManager.isExecutableFileAtPath(path)));\n      break;\n  }\n\n  if (!canAccess) {\n    throw new Error(\"Can't access \" + String(path));\n  }\n};\n\nmodule.exports.appendFile = NOT_IMPLEMENTED(\"appendFile\");\n\nmodule.exports.appendFileSync = function (file, data, options) {\n  if (!module.exports.existsSync(file)) {\n    return module.exports.writeFileSync(file, data, options);\n  }\n\n  var handle = NSFileHandle.fileHandleForWritingAtPath(file);\n  handle.seekToEndOfFile();\n\n  var encoding = encodingFromOptions(options, \"utf8\");\n\n  var nsdata = Buffer.from(\n    data,\n    encoding === \"NSData\" || encoding === \"buffer\" ? undefined : encoding\n  ).toNSData();\n\n  handle.writeData(nsdata);\n};\n\nmodule.exports.chmod = NOT_IMPLEMENTED(\"chmod\");\n\nmodule.exports.chmodSync = function (path, mode) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.setAttributes_ofItemAtPath_error(\n    {\n      NSFilePosixPermissions: mode,\n    },\n    path,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n};\n\nmodule.exports.chown = NOT_IMPLEMENTED(\"chown\");\nmodule.exports.chownSync = NOT_IMPLEMENTED(\"chownSync\");\n\nmodule.exports.close = NOT_IMPLEMENTED(\"close\");\nmodule.exports.closeSync = NOT_IMPLEMENTED(\"closeSync\");\n\nmodule.exports.copyFile = NOT_IMPLEMENTED(\"copyFile\");\n\nmodule.exports.copyFileSync = function (path, dest, flags) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.copyItemAtPath_toPath_error(path, dest, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, false, err.value());\n  }\n};\n\nmodule.exports.createReadStream = NOT_IMPLEMENTED(\"createReadStream\");\nmodule.exports.createWriteStream = NOT_IMPLEMENTED(\"createWriteStream\");\n\nmodule.exports.exists = NOT_IMPLEMENTED(\"exists\");\n\nmodule.exports.existsSync = function (path) {\n  var fileManager = NSFileManager.defaultManager();\n  return Boolean(Number(fileManager.fileExistsAtPath(path)));\n};\n\nmodule.exports.fchmod = NOT_IMPLEMENTED(\"fchmod\");\nmodule.exports.fchmodSync = NOT_IMPLEMENTED(\"fchmodSync\");\nmodule.exports.fchown = NOT_IMPLEMENTED(\"fchown\");\nmodule.exports.fchownSync = NOT_IMPLEMENTED(\"fchownSync\");\nmodule.exports.fdatasync = NOT_IMPLEMENTED(\"fdatasync\");\nmodule.exports.fdatasyncSync = NOT_IMPLEMENTED(\"fdatasyncSync\");\nmodule.exports.fstat = NOT_IMPLEMENTED(\"fstat\");\nmodule.exports.fstatSync = NOT_IMPLEMENTED(\"fstatSync\");\nmodule.exports.fsync = NOT_IMPLEMENTED(\"fsync\");\nmodule.exports.fsyncSync = NOT_IMPLEMENTED(\"fsyncSync\");\nmodule.exports.ftruncate = NOT_IMPLEMENTED(\"ftruncate\");\nmodule.exports.ftruncateSync = NOT_IMPLEMENTED(\"ftruncateSync\");\nmodule.exports.futimes = NOT_IMPLEMENTED(\"futimes\");\nmodule.exports.futimesSync = NOT_IMPLEMENTED(\"futimesSync\");\n\nmodule.exports.lchmod = NOT_IMPLEMENTED(\"lchmod\");\nmodule.exports.lchmodSync = NOT_IMPLEMENTED(\"lchmodSync\");\nmodule.exports.lchown = NOT_IMPLEMENTED(\"lchown\");\nmodule.exports.lchownSync = NOT_IMPLEMENTED(\"lchownSync\");\n\nmodule.exports.link = NOT_IMPLEMENTED(\"link\");\n\nmodule.exports.linkSync = function (existingPath, newPath) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.linkItemAtPath_toPath_error(existingPath, newPath, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(existingPath, undefined, err.value());\n  }\n};\n\nmodule.exports.lstat = NOT_IMPLEMENTED(\"lstat\");\n\nmodule.exports.lstatSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.attributesOfItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n\n  return parseStat(result);\n};\n\nmodule.exports.mkdir = NOT_IMPLEMENTED(\"mkdir\");\n\nmodule.exports.mkdirSync = function (path, options) {\n  var mode = 0o777;\n  var recursive = false;\n  if (options && options.mode) {\n    mode = options.mode;\n  }\n  if (options && options.recursive) {\n    recursive = options.recursive;\n  }\n  if (typeof options === \"number\") {\n    mode = options;\n  }\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.createDirectoryAtPath_withIntermediateDirectories_attributes_error(\n    path,\n    recursive,\n    {\n      NSFilePosixPermissions: mode,\n    },\n    err\n  );\n\n  if (err.value() !== null) {\n    throw new Error(err.value());\n  }\n};\n\nmodule.exports.mkdtemp = NOT_IMPLEMENTED(\"mkdtemp\");\n\nmodule.exports.mkdtempSync = function (path) {\n  function makeid() {\n    var text = \"\";\n    var possible =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n    for (var i = 0; i < 6; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n  var tempPath = path + makeid();\n  module.exports.mkdirSync(tempPath);\n  return tempPath;\n};\n\nmodule.exports.open = NOT_IMPLEMENTED(\"open\");\nmodule.exports.openSync = NOT_IMPLEMENTED(\"openSync\");\n\nmodule.exports.read = NOT_IMPLEMENTED(\"read\");\n\nmodule.exports.readdir = NOT_IMPLEMENTED(\"readdir\");\n\nmodule.exports.readdirSync = function (path, options) {\n  var encoding = encodingFromOptions(options, \"utf8\");\n  var fileManager = NSFileManager.defaultManager();\n  var paths = fileManager.subpathsAtPath(path);\n  var arr = [];\n  for (var i = 0; i < paths.length; i++) {\n    var pathName = paths[i];\n    arr.push(encoding === \"buffer\" ? Buffer.from(pathName) : String(pathName));\n  }\n  return arr;\n};\n\nmodule.exports.readFile = NOT_IMPLEMENTED(\"readFile\");\n\nmodule.exports.readFileSync = function (path, options) {\n  var encoding = encodingFromOptions(options, \"buffer\");\n  var fileManager = NSFileManager.defaultManager();\n  var data = fileManager.contentsAtPath(path);\n  if (!data) {\n    throw fsErrorForPath(path, false);\n  }\n\n  var buffer = Buffer.from(data);\n\n  if (encoding === \"buffer\") {\n    return buffer;\n  } else if (encoding === \"NSData\") {\n    return buffer.toNSData();\n  } else {\n    return buffer.toString(encoding);\n  }\n};\n\nmodule.exports.readlink = NOT_IMPLEMENTED(\"readlink\");\n\nmodule.exports.readlinkSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.destinationOfSymbolicLinkAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n\n  return String(result);\n};\n\nmodule.exports.readSync = NOT_IMPLEMENTED(\"readSync\");\n\nmodule.exports.realpath = NOT_IMPLEMENTED(\"realpath\");\nmodule.exports.realpath.native = NOT_IMPLEMENTED(\"realpath.native\");\n\nmodule.exports.realpathSync = function (path) {\n  return String(\n    NSString.stringWithString(path).stringByResolvingSymlinksInPath()\n  );\n};\n\nmodule.exports.realpathSync.native = NOT_IMPLEMENTED(\"realpathSync.native\");\n\nmodule.exports.rename = NOT_IMPLEMENTED(\"rename\");\n\nmodule.exports.renameSync = function (oldPath, newPath) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  fileManager.moveItemAtPath_toPath_error(oldPath, newPath, err);\n\n  var error = err.value();\n\n  if (error !== null) {\n    // if there is already a file, we need to overwrite it\n    if (\n      String(error.domain()) === \"NSCocoaErrorDomain\" &&\n      Number(error.code()) === 516\n    ) {\n      var err2 = MOPointer.alloc().init();\n      fileManager.replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(\n        NSURL.fileURLWithPath(newPath),\n        NSURL.fileURLWithPath(oldPath),\n        null,\n        NSFileManagerItemReplacementUsingNewMetadataOnly,\n        null,\n        err2\n      );\n      if (err2.value() !== null) {\n        throw fsErrorForPath(oldPath, undefined, err2.value());\n      }\n    } else {\n      throw fsErrorForPath(oldPath, undefined, error);\n    }\n  }\n};\n\nmodule.exports.rmdir = NOT_IMPLEMENTED(\"rmdir\");\n\nmodule.exports.rmdirSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var isDirectory = module.exports.lstatSync(path).isDirectory();\n  if (!isDirectory) {\n    throw fsError(\"ENOTDIR\", {\n      path: path,\n      syscall: \"rmdir\",\n    });\n  }\n  fileManager.removeItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, true, err.value(), \"rmdir\");\n  }\n};\n\nmodule.exports.stat = NOT_IMPLEMENTED(\"stat\");\n\n// the only difference with lstat is that we resolve symlinks\n//\n// > lstat() is identical to stat(), except that if pathname is a symbolic\n// > link, then it returns information about the link itself, not the file\n// > that it refers to.\n// http://man7.org/linux/man-pages/man2/lstat.2.html\nmodule.exports.statSync = function (path) {\n  return module.exports.lstatSync(module.exports.realpathSync(path));\n};\n\nmodule.exports.symlink = NOT_IMPLEMENTED(\"symlink\");\n\nmodule.exports.symlinkSync = function (target, path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.createSymbolicLinkAtPath_withDestinationPath_error(\n    path,\n    target,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw new Error(err.value());\n  }\n};\n\nmodule.exports.truncate = NOT_IMPLEMENTED(\"truncate\");\n\nmodule.exports.truncateSync = function (path, len) {\n  var hFile = NSFileHandle.fileHandleForUpdatingAtPath(sFilePath);\n  hFile.truncateFileAtOffset(len || 0);\n  hFile.closeFile();\n};\n\nmodule.exports.unlink = NOT_IMPLEMENTED(\"unlink\");\n\nmodule.exports.unlinkSync = function (path) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var isDirectory = module.exports.lstatSync(path).isDirectory();\n  if (isDirectory) {\n    throw fsError(\"EPERM\", {\n      path: path,\n      syscall: \"unlink\",\n    });\n  }\n  var result = fileManager.removeItemAtPath_error(path, err);\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, false, err.value());\n  }\n};\n\nmodule.exports.unwatchFile = NOT_IMPLEMENTED(\"unwatchFile\");\n\nmodule.exports.utimes = NOT_IMPLEMENTED(\"utimes\");\n\nmodule.exports.utimesSync = function (path, aTime, mTime) {\n  var err = MOPointer.alloc().init();\n  var fileManager = NSFileManager.defaultManager();\n  var result = fileManager.setAttributes_ofItemAtPath_error(\n    {\n      NSFileModificationDate: aTime,\n    },\n    path,\n    err\n  );\n\n  if (err.value() !== null) {\n    throw fsErrorForPath(path, undefined, err.value());\n  }\n};\n\nmodule.exports.watch = NOT_IMPLEMENTED(\"watch\");\nmodule.exports.watchFile = NOT_IMPLEMENTED(\"watchFile\");\n\nmodule.exports.write = NOT_IMPLEMENTED(\"write\");\n\nmodule.exports.writeFile = NOT_IMPLEMENTED(\"writeFile\");\n\nmodule.exports.writeFileSync = function (path, data, options) {\n  var encoding = encodingFromOptions(options, \"utf8\");\n\n  var nsdata = Buffer.from(\n    data,\n    encoding === \"NSData\" || encoding === \"buffer\" ? undefined : encoding\n  ).toNSData();\n\n  nsdata.writeToFile_atomically(path, true);\n};\n\nmodule.exports.writeSync = NOT_IMPLEMENTED(\"writeSync\");\n","module.exports.parseStat = function parseStat(result) {\n  return {\n    dev: String(result.NSFileDeviceIdentifier),\n    // ino: 48064969, The file system specific \"Inode\" number for the file.\n    mode: result.NSFileType | result.NSFilePosixPermissions,\n    nlink: Number(result.NSFileReferenceCount),\n    uid: String(result.NSFileOwnerAccountID),\n    gid: String(result.NSFileGroupOwnerAccountID),\n    // rdev: 0, A numeric device identifier if the file is considered \"special\".\n    size: Number(result.NSFileSize),\n    // blksize: 4096, The file system block size for i/o operations.\n    // blocks: 8, The number of blocks allocated for this file.\n    atimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    mtimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    ctimeMs:\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000,\n    birthtimeMs:\n      Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000,\n    atime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ), // the 0.5 comes from the node source. Not sure why it's added but in doubt...\n    mtime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    ctime: new Date(\n      Number(result.NSFileModificationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    birthtime: new Date(\n      Number(result.NSFileCreationDate.timeIntervalSince1970()) * 1000 + 0.5\n    ),\n    isBlockDevice: function () {\n      return result.NSFileType === NSFileTypeBlockSpecial;\n    },\n    isCharacterDevice: function () {\n      return result.NSFileType === NSFileTypeCharacterSpecial;\n    },\n    isDirectory: function () {\n      return result.NSFileType === NSFileTypeDirectory;\n    },\n    isFIFO: function () {\n      return false;\n    },\n    isFile: function () {\n      return result.NSFileType === NSFileTypeRegular;\n    },\n    isSocket: function () {\n      return result.NSFileType === NSFileTypeSocket;\n    },\n    isSymbolicLink: function () {\n      return result.NSFileType === NSFileTypeSymbolicLink;\n    },\n  };\n};\n\nvar ERRORS = {\n  EPERM: {\n    message: \"operation not permitted\",\n    errno: -1,\n  },\n  ENOENT: {\n    message: \"no such file or directory\",\n    errno: -2,\n  },\n  EACCES: {\n    message: \"permission denied\",\n    errno: -13,\n  },\n  ENOTDIR: {\n    message: \"not a directory\",\n    errno: -20,\n  },\n  EISDIR: {\n    message: \"illegal operation on a directory\",\n    errno: -21,\n  },\n};\n\nfunction fsError(code, options) {\n  var error = new Error(\n    code +\n      \": \" +\n      ERRORS[code].message +\n      \", \" +\n      (options.syscall || \"\") +\n      (options.path ? \" '\" + options.path + \"'\" : \"\")\n  );\n\n  Object.keys(options).forEach(function (k) {\n    error[k] = options[k];\n  });\n\n  error.code = code;\n  error.errno = ERRORS[code].errno;\n\n  return error;\n}\n\nmodule.exports.fsError = fsError;\n\nmodule.exports.fsErrorForPath = function fsErrorForPath(\n  path,\n  shouldBeDir,\n  err,\n  syscall\n) {\n  var fileManager = NSFileManager.defaultManager();\n  var doesExist = fileManager.fileExistsAtPath(path);\n  if (!doesExist) {\n    return fsError(\"ENOENT\", {\n      path: path,\n      syscall: syscall || \"open\",\n    });\n  }\n  var isReadable = fileManager.isReadableFileAtPath(path);\n  if (!isReadable) {\n    return fsError(\"EACCES\", {\n      path: path,\n      syscall: syscall || \"open\",\n    });\n  }\n  if (typeof shouldBeDir !== \"undefined\") {\n    var isDirectory = require(\"./index\").lstatSync(path).isDirectory();\n    if (isDirectory && !shouldBeDir) {\n      return fsError(\"EISDIR\", {\n        path: path,\n        syscall: syscall || \"read\",\n      });\n    } else if (!isDirectory && shouldBeDir) {\n      return fsError(\"ENOTDIR\", {\n        path: path,\n        syscall: syscall || \"read\",\n      });\n    }\n  }\n  return new Error(err || \"Unknown error while manipulating \" + path);\n};\n\nmodule.exports.encodingFromOptions = function encodingFromOptions(\n  options,\n  defaultValue\n) {\n  return options && options.encoding\n    ? String(options.encoding)\n    : options\n    ? String(options)\n    : defaultValue;\n};\n\nmodule.exports.NOT_IMPLEMENTED = function NOT_IMPLEMENTED(name) {\n  return function () {\n    throw new Error(\n      \"fs.\" +\n        name +\n        \" is not implemented yet. If you feel like implementing it, any contribution will be gladly accepted on https://github.com/skpm/fs\"\n    );\n  };\n};\n","const fs = require('@skpm/fs')\nconst childProcess = require('@skpm/child_process')\n\nconst numCols = 16\nconst artboardSize = 64\nconst padding = 32\nconst cellSpan = artboardSize + padding\n\nimport sketch from 'sketch'\n\nexport default function(context) {\n    // determine the location of the clypboard-server directory from puma-dev\n    const pumaDir = \"~/.puma-dev/clypboard-server\"\n    let clypboardDir = childProcess.execSync(`readlink ${pumaDir}`).toString()\n    if (clypboardDir.indexOf('clypboard-server')>-1) {\n        clypboardDir = clypboardDir.trim()\n        console.log(`Clypboard directory: ${clypboardDir}`)\n    }\n    else {\n        UI.alert('No Clypboard Directory!', `The Glyp plugin assumes that you have a local Clypboard instance that's linked to at ${pumaDir}`)\n        return\n    }\n\n    const document = sketch.Document.getSelectedDocument()\n    let page = document.selectedPage\n    if (page) {\n        page.name = 'Glyps'\n        for (const child of page.layers) {\n            child.remove()\n        }\n    }\n    else {\n        page = new sketch.Page({\n            parent: document,\n            name: \"Glyps\"\n        })\n    }\n\n    const rootDir = `${clypboardDir}/public/glyp`\n\n    const files = fs.readdirSync(rootDir)\n    let col = 0\n    let row = 0\n    let names = []\n    for (const file of files) {\n        if (file.endsWith('.svg')) {\n            names.push(file)\n        }\n    }\n\n    for (const file of names.sort()) {\n        const x = col * cellSpan\n        const y = row * cellSpan\n        console.log(`Adding ${file} at ${x},${y}`)\n\n        // create the artboard\n        const artboard = new sketch.Artboard({\n            parent: page,\n            name: file.replace('.svg', ''),\n            frame: {\n                x: x,\n                y: y,\n                width: artboardSize,\n                height: artboardSize\n            },\n            exportFormats: [\n                {\n                    fileFormat: 'svg'\n                }\n            ]\n        })\n\n        // load the svg file\n        const svg = fs.readFileSync(`${rootDir}/${file}`)\n        const group = sketch.createLayerFromData(svg, 'svg')\n        for (const layer of group.layers) {\n            layer.frame.x += group.frame.x\n            layer.frame.y += group.frame.y\n            layer.parent = artboard\n        }\n\n        // set the grid\n        const grid = MSDefaultGrid.defaultGrid()\n        grid.setGridSize(4)\n        grid.setThickGridTimes(2)\n        grid.setIsEnabled(true)\n        artboard.sketchObject.setGrid(grid)\n\n        col += 1\n        if (col >= numCols) {\n            col = 0\n            row += 1\n        }\n    }\n\n\n    sketch.UI.message(`Imported ${names.length} Glyps!`)\n\n}","module.exports = require(\"buffer\");","module.exports = require(\"events\");","module.exports = require(\"sketch\");","module.exports = require(\"stream\");"],"sourceRoot":""}