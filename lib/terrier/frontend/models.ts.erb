// noinspection JSAnnotator,ES6UnusedImports,TypeScriptCheckImport,TypeScriptValidateTypes,TypeScriptUnresolvedFunction,TypeScriptUnresolvedVariable

<% @imports.each do |path, symbols| %>
  import {<%= symbols.join(', ') %>} from "<%= path %>"
<% end %>

<% models.keys.sort.each do |model_name| %>
  <% model = models[model_name] %>

  export type <%= build_typescript_model_type(model_name, model) %>
  
  export type Unpersisted<%= build_typescript_model_type(model_name, model, true) %>

  <% if model[:enum_fields].present? -%>
    export const <%= model_name.split('::').last %>EnumFields = {
    <% model[:enum_fields].each do |col, values| -%>
      <% next if model[:enum_fields].blank? -%>
      <%= col %>: [<%= values.select(&:present?).map{|f| "'#{f}'"}.join(',') %>] as const,
    <% end -%>
    }
  <% end -%>

<% end %>

<% @reflections_like_types.each do |model_name, type| %>
  export type <%= "#{model_name} = | #{type}" %>
<% end %>

/**
 * Map model names to their types.
 */
export type PersistedModelTypeMap = {
  <% models.keys.sort.each do |model_name| -%>
    <%= model_name.tableize.singularize.split('/').last %>: <%= model_name.split('::').last %>
  <% end -%>
}

/**
 * Map model names to their unpersisted types.
 */
export type UnpersistedModelTypeMap = {
  <% models.keys.sort.each do |model_name| -%>
    <%= model_name.tableize.singularize.split('/').last %>: Unpersisted<%= model_name.split('::').last %>
  <% end -%>
}

/**
 * Map model names to their association names.
 */
export type ModelIncludesMap = {
  <% models.keys.sort.each do |model_name| -%>
    <% refs = models[model_name][:reflections] -%>
    <%= model_name.tableize.singularize.split('/').last %>: <%= refs.empty? ? 'never' : refs.keys.sort.map{|r| "'#{r}'"}.join(' | ') %>
  <% end -%>
}

/**
 * Map model names to an array of association names.
 */
export const ModelIncludesArrayMap = {
  <% models.keys.sort.each do |model_name| -%>
    <% refs = models[model_name][:reflections] -%>
    <%= model_name.tableize.singularize.split('/').last %>: [<%= refs.keys.sort.map{|r| "'#{r}'"}.join(', ') %>] as const,
  <% end -%>
}

/**
 * Map "sluggable" model names to their types
 */
export type SluggableModelTypeMap = {
  <% models.keys.sort.each do |model_name| -%>
    <% next unless models[model_name][:columns].map(&:name).include?('slug') -%>
    <%= model_name.tableize.singularize.split('/').last %>: <%= model_name.split('::').last %>
  <% end -%>
}

/**
 * A type consisting of all possible model names.
 */
export type ModelName = keyof PersistedModelTypeMap & keyof UnpersistedModelTypeMap