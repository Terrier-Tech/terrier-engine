// noinspection JSAnnotator,ES6UnusedImports,TypeScriptCheckImport,TypeScriptValidateTypes,TypeScriptUnresolvedFunction,TypeScriptUnresolvedVariable

import {OptionalProps} from "tuff-core/types"
<% if @has_shrine %>
import {Attachment} from "../services/attachments"
<% end %>

<% models.keys.sort.each do |model_name| %>

export type <%= model_name %> = {
<% models[model_name][:columns].each do |col| %>
  <%= col.name %><%= col.null ? '?' : '' %>: <%= typescript_type(col, models[model_name][:model_class], models[model_name][:enum_fields][col.name.to_sym]) %>
<% end %>
<% models[model_name][:reflections].each do |ref_name, ref| %>
  <% ref_type = ref.options[:class_name].presence || ref.name.to_s.classify %>
  <% ref_type += '[]' if ref.class == ActiveRecord::Reflection::HasManyReflection %>
  <%= ref_name %> ? : <%= ref_type %>
<% end %>
<% models[model_name][:attachments].each do |attachment| %>
    <%= attachment %> ? : File
<% end %>
}

export type Unpersisted<%= model_name %> = {
  <% models[model_name][:columns].each do |col| %>
  <%= col.name %><%= col.null || unpersisted_columns.include?(col.name) ? '?' : '' %>: <%= typescript_type(col, models[model_name][:model_class], models[model_name][:enum_fields][col.name.to_sym]) %>
    <% end %>
    <% models[model_name][:reflections].each do |ref_name, ref| %>
    <% ref_type = ref.options[:class_name].presence || ref.name.to_s.classify %>
    <% if ref.class == ActiveRecord::Reflection::HasManyReflection %>
    <% fk = ref.options[:foreign_key].presence || "#{model_name.tableize.singularize}_id" %>
    <% ref_type = "OptionalProps<Unpersisted#{ref_type},'#{fk}'>[]" %>
    <% end %>
    <%= ref_name %>?: <%= ref_type %>
    <% end %>
    <% models[model_name][:attachments].each do |attachment| %>
    <%= attachment %>?: File
  <% end %>
}

<% if models[model_name][:enum_fields].present? %>
export const <%= model_name %>EnumFields = {
<% models[model_name][:enum_fields].each do |col, values| %>
<%= col %>: [<%= values.select(&:present?).map{|f| "'#{f}'"}.join(',') %>] as const,
<% end %>
}
<% end %>

<% end %>

/**
 * Map model names to their types.
 */
export type ModelTypeMap = {
  <% models.keys.sort.each do |model_name| %>
  <%= model_name.tableize.singularize %>: <%= model_name %>
  <% end %>
}

/**
 * Map model names to their unpersisted types.
 */
export type UnpersistedModelTypeMap = {
  <% models.keys.sort.each do |model_name| %>
  <%= model_name.tableize.singularize %>: Unpersisted<%= model_name %>
  <% end %>
}

/**
 * Map model names to their association names.
 */
export type ModelIncludesMap = {
  <% models.keys.sort.each do |model_name| %>
  <% refs = models[model_name][:reflections] %>
  <%= model_name.tableize.singularize %>: <%= refs.empty? ? 'never' : refs.keys.sort.map{|r| "'#{r}'"}.join(' | ') %>
  <% end %>
}

/**
 * Map "sluggable" model names to their types
 */
export type SluggableModelTypeMap = {
  <% models.keys.sort.each do |model_name| %>
  <% next unless models[model_name][:columns].map(&:name).include?('slug') %>
  <%= model_name.tableize.singularize %>: <%= model_name %>
  <% end %>
}

/**
 * A type consisting of all possible model names.
 */
export type ModelName = keyof ModelTypeMap